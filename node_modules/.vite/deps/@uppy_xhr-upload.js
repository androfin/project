import {
  BasePlugin,
  EventManager,
  NetworkError_default,
  RateLimitedQueue,
  fetcher,
  filterFilesToEmitUploadStarted,
  filterNonFailedFiles,
  getAllowedMetaFields,
  internalRateLimitedQueue,
  isNetworkError_default
} from "./chunk-CBPIEH2G.js";
import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField
} from "./chunk-WOOG5QLI.js";

// node_modules/@uppy/xhr-upload/package.json
var package_default = {
  name: "@uppy/xhr-upload",
  description: "Plain and simple classic HTML multipart form uploads with Uppy, as well as uploads using the HTTP PUT method.",
  version: "5.0.2",
  license: "MIT",
  type: "module",
  sideEffects: false,
  scripts: {
    build: "tsc --build tsconfig.build.json",
    typecheck: "tsc --build",
    test: "vitest run --environment=jsdom --silent='passed-only'"
  },
  keywords: [
    "file uploader",
    "xhr",
    "xhr upload",
    "XMLHttpRequest",
    "ajax",
    "fetch",
    "uppy",
    "uppy-plugin"
  ],
  homepage: "https://uppy.io",
  bugs: {
    url: "https://github.com/transloadit/uppy/issues"
  },
  repository: {
    type: "git",
    url: "git+https://github.com/transloadit/uppy.git"
  },
  files: [
    "src",
    "lib",
    "dist",
    "CHANGELOG.md"
  ],
  exports: {
    ".": "./lib/index.js",
    "./package.json": "./package.json"
  },
  dependencies: {
    "@uppy/companion-client": "^5.1.1",
    "@uppy/utils": "^7.1.1"
  },
  devDependencies: {
    "@uppy/core": "^5.1.1",
    jsdom: "^26.1.0",
    nock: "^13.1.0",
    typescript: "^5.8.3",
    vitest: "^3.2.4"
  },
  peerDependencies: {
    "@uppy/core": "^5.1.1"
  }
};

// node_modules/@uppy/xhr-upload/lib/locale.js
var locale_default = {
  strings: {
    // Shown in the Informer if an upload is being canceled because it stalled for too long.
    uploadStalled: "Upload has not made any progress for %{seconds} seconds. You may want to retry it."
  }
};

// node_modules/@uppy/xhr-upload/lib/index.js
function buildResponseError(xhr, err) {
  let error = err;
  if (!error)
    error = new Error("Upload error");
  if (typeof error === "string")
    error = new Error(error);
  if (!(error instanceof Error)) {
    error = Object.assign(new Error("Upload error"), { data: error });
  }
  if (isNetworkError_default(xhr)) {
    error = new NetworkError_default(error, xhr);
    return error;
  }
  error.request = xhr;
  return error;
}
function setTypeInBlob(file) {
  const dataWithUpdatedType = file.data.slice(0, file.data.size, file.meta.type);
  return dataWithUpdatedType;
}
var defaultOptions = {
  formData: true,
  fieldName: "file",
  method: "post",
  allowedMetaFields: true,
  bundle: false,
  headers: {},
  timeout: 30 * 1e3,
  limit: 5,
  withCredentials: false,
  responseType: ""
};
var _getFetcher, _XHRUpload_instances, uploadLocalFile_fn, uploadBundle_fn, getCompanionClientArgs_fn, uploadFiles_fn, _handleUpload;
var XHRUpload = class extends BasePlugin {
  constructor(uppy, opts) {
    super(uppy, {
      ...defaultOptions,
      fieldName: opts.bundle ? "files[]" : "file",
      ...opts
    });
    __privateAdd(this, _XHRUpload_instances);
    __privateAdd(this, _getFetcher);
    __publicField(this, "requests");
    __publicField(this, "uploaderEvents");
    __privateAdd(this, _handleUpload, async (fileIDs) => {
      if (fileIDs.length === 0) {
        this.uppy.log("[XHRUpload] No files to upload!");
        return;
      }
      if (this.opts.limit === 0 && !this.opts[internalRateLimitedQueue]) {
        this.uppy.log("[XHRUpload] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/xhr-upload/#limit-0", "warning");
      }
      this.uppy.log("[XHRUpload] Uploading...");
      const files = this.uppy.getFilesByIds(fileIDs);
      const filesFiltered = filterNonFailedFiles(files);
      const filesToEmit = filterFilesToEmitUploadStarted(filesFiltered);
      this.uppy.emit("upload-start", filesToEmit);
      if (this.opts.bundle) {
        const isSomeFileRemote = filesFiltered.some((file) => file.isRemote);
        if (isSomeFileRemote) {
          throw new Error("Canâ€™t upload remote files when the `bundle: true` option is set");
        }
        if (typeof this.opts.headers === "function") {
          throw new TypeError("`headers` may not be a function when the `bundle: true` option is set");
        }
        await __privateMethod(this, _XHRUpload_instances, uploadBundle_fn).call(this, filesFiltered);
      } else {
        await __privateMethod(this, _XHRUpload_instances, uploadFiles_fn).call(this, filesFiltered);
      }
    });
    this.type = "uploader";
    this.id = this.opts.id || "XHRUpload";
    this.defaultLocale = locale_default;
    this.i18nInit();
    if (internalRateLimitedQueue in this.opts) {
      this.requests = this.opts[internalRateLimitedQueue];
    } else {
      this.requests = new RateLimitedQueue(this.opts.limit);
    }
    if (this.opts.bundle && !this.opts.formData) {
      throw new Error("`opts.formData` must be true when `opts.bundle` is enabled.");
    }
    if (this.opts.bundle && typeof this.opts.headers === "function") {
      throw new Error("`opts.headers` can not be a function when the `bundle: true` option is set.");
    }
    if ((opts == null ? void 0 : opts.allowedMetaFields) === void 0 && "metaFields" in this.opts) {
      throw new Error("The `metaFields` option has been renamed to `allowedMetaFields`.");
    }
    this.uploaderEvents = /* @__PURE__ */ Object.create(null);
    __privateSet(this, _getFetcher, (files) => {
      return async (url, options) => {
        var _a, _b;
        try {
          const res = await fetcher(url, {
            ...options,
            onBeforeRequest: (xhr, retryCount) => {
              var _a2, _b2;
              return (_b2 = (_a2 = this.opts).onBeforeRequest) == null ? void 0 : _b2.call(_a2, xhr, retryCount, files);
            },
            shouldRetry: this.opts.shouldRetry,
            onAfterResponse: this.opts.onAfterResponse,
            onTimeout: (timeout) => {
              const seconds = Math.ceil(timeout / 1e3);
              const error = new Error(this.i18n("uploadStalled", { seconds }));
              this.uppy.emit("upload-stalled", error, files);
            },
            onUploadProgress: (event) => {
              if (event.lengthComputable) {
                for (const { id } of files) {
                  const file = this.uppy.getFile(id);
                  this.uppy.emit("upload-progress", file, {
                    uploadStarted: file.progress.uploadStarted ?? 0,
                    bytesUploaded: event.loaded / event.total * file.size,
                    bytesTotal: file.size
                  });
                }
              }
            }
          });
          let body = await ((_b = (_a = this.opts).getResponseData) == null ? void 0 : _b.call(_a, res));
          if (res.responseType === "json") {
            body ?? (body = res.response);
          } else {
            try {
              body ?? (body = JSON.parse(res.responseText));
            } catch (cause) {
              throw new Error("@uppy/xhr-upload expects a JSON response (with a `url` property). To parse non-JSON responses, use `getResponseData` to turn your response into JSON.", { cause });
            }
          }
          const uploadURL = typeof (body == null ? void 0 : body.url) === "string" ? body.url : void 0;
          for (const { id } of files) {
            this.uppy.emit("upload-success", this.uppy.getFile(id), {
              status: res.status,
              body,
              uploadURL
            });
          }
          return res;
        } catch (error) {
          if (error.name === "AbortError") {
            return void 0;
          }
          const request = error.request;
          for (const file of files) {
            this.uppy.emit("upload-error", this.uppy.getFile(file.id), buildResponseError(request, error), request);
          }
          throw error;
        }
      };
    });
  }
  getOptions(file) {
    const overrides = this.uppy.getState().xhrUpload;
    const { headers } = this.opts;
    const opts = {
      ...this.opts,
      ...overrides || {},
      ...file.xhrUpload || {},
      headers: {}
    };
    if (typeof headers === "function") {
      opts.headers = headers(file);
    } else {
      Object.assign(opts.headers, this.opts.headers);
    }
    if (overrides) {
      Object.assign(opts.headers, overrides.headers);
    }
    if (file.xhrUpload) {
      Object.assign(opts.headers, file.xhrUpload.headers);
    }
    return opts;
  }
  addMetadata(formData, meta, opts) {
    const allowedMetaFields = getAllowedMetaFields(opts.allowedMetaFields, meta);
    allowedMetaFields.forEach((item) => {
      const value = meta[item];
      if (Array.isArray(value)) {
        value.forEach((subItem) => formData.append(item, subItem));
      } else {
        formData.append(item, value);
      }
    });
  }
  createFormDataUpload(file, opts) {
    const formPost = new FormData();
    this.addMetadata(formPost, file.meta, opts);
    const dataWithUpdatedType = setTypeInBlob(file);
    if (file.name) {
      formPost.append(opts.fieldName, dataWithUpdatedType, file.meta.name);
    } else {
      formPost.append(opts.fieldName, dataWithUpdatedType);
    }
    return formPost;
  }
  createBundledUpload(files, opts) {
    const formPost = new FormData();
    const { meta } = this.uppy.getState();
    this.addMetadata(formPost, meta, opts);
    files.forEach((file) => {
      const options = this.getOptions(file);
      const dataWithUpdatedType = setTypeInBlob(file);
      if (file.name) {
        formPost.append(options.fieldName, dataWithUpdatedType, file.name);
      } else {
        formPost.append(options.fieldName, dataWithUpdatedType);
      }
    });
    return formPost;
  }
  install() {
    if (this.opts.bundle) {
      const { capabilities } = this.uppy.getState();
      this.uppy.setState({
        capabilities: {
          ...capabilities,
          individualCancellation: false
        }
      });
    }
    this.uppy.addUploader(__privateGet(this, _handleUpload));
  }
  uninstall() {
    if (this.opts.bundle) {
      const { capabilities } = this.uppy.getState();
      this.uppy.setState({
        capabilities: {
          ...capabilities,
          individualCancellation: true
        }
      });
    }
    this.uppy.removeUploader(__privateGet(this, _handleUpload));
  }
};
_getFetcher = new WeakMap();
_XHRUpload_instances = new WeakSet();
uploadLocalFile_fn = async function(file) {
  const events = new EventManager(this.uppy);
  const controller = new AbortController();
  const uppyFetch = this.requests.wrapPromiseFunction(async () => {
    const opts = this.getOptions(file);
    const fetch = __privateGet(this, _getFetcher).call(this, [file]);
    const body = opts.formData ? this.createFormDataUpload(file, opts) : file.data;
    const endpoint = typeof opts.endpoint === "string" ? opts.endpoint : await opts.endpoint(file);
    return fetch(endpoint, {
      ...opts,
      body,
      signal: controller.signal
    });
  });
  events.onFileRemove(file.id, () => controller.abort());
  events.onCancelAll(file.id, () => {
    controller.abort();
  });
  try {
    await uppyFetch().abortOn(controller.signal);
  } catch (error) {
    if (error.message !== "Cancelled") {
      throw error;
    }
  } finally {
    events.remove();
  }
};
uploadBundle_fn = async function(files) {
  const controller = new AbortController();
  const uppyFetch = this.requests.wrapPromiseFunction(async () => {
    const optsFromState = this.uppy.getState().xhrUpload ?? {};
    const fetch = __privateGet(this, _getFetcher).call(this, files);
    const body = this.createBundledUpload(files, {
      ...this.opts,
      ...optsFromState
    });
    const endpoint = typeof this.opts.endpoint === "string" ? this.opts.endpoint : await this.opts.endpoint(files);
    return fetch(endpoint, {
      // headers can't be a function with bundle: true
      ...this.opts,
      body,
      signal: controller.signal
    });
  });
  function abort() {
    controller.abort();
  }
  this.uppy.once("cancel-all", abort);
  try {
    await uppyFetch().abortOn(controller.signal);
  } catch (error) {
    if (error.message !== "Cancelled") {
      throw error;
    }
  } finally {
    this.uppy.off("cancel-all", abort);
  }
};
getCompanionClientArgs_fn = function(file) {
  var _a;
  const opts = this.getOptions(file);
  const allowedMetaFields = getAllowedMetaFields(opts.allowedMetaFields, file.meta);
  return {
    ...(_a = file.remote) == null ? void 0 : _a.body,
    protocol: "multipart",
    endpoint: opts.endpoint,
    size: file.data.size,
    fieldname: opts.fieldName,
    metadata: Object.fromEntries(allowedMetaFields.map((name) => [name, file.meta[name]])),
    httpMethod: opts.method,
    useFormData: opts.formData,
    headers: opts.headers
  };
};
uploadFiles_fn = async function(files) {
  await Promise.allSettled(files.map((file) => {
    if (file.isRemote) {
      const getQueue = () => this.requests;
      const controller = new AbortController();
      const removedHandler = (removedFile) => {
        if (removedFile.id === file.id)
          controller.abort();
      };
      this.uppy.on("file-removed", removedHandler);
      const uploadPromise = this.uppy.getRequestClientForFile(file).uploadRemoteFile(file, __privateMethod(this, _XHRUpload_instances, getCompanionClientArgs_fn).call(this, file), {
        signal: controller.signal,
        getQueue
      });
      this.requests.wrapSyncFunction(() => {
        this.uppy.off("file-removed", removedHandler);
      }, { priority: -1 })();
      return uploadPromise;
    }
    return __privateMethod(this, _XHRUpload_instances, uploadLocalFile_fn).call(this, file);
  }));
};
_handleUpload = new WeakMap();
__publicField(XHRUpload, "VERSION", package_default.version);
export {
  XHRUpload as default
};
//# sourceMappingURL=@uppy_xhr-upload.js.map
