{
  "version": 3,
  "sources": ["../../@uppy/xhr-upload/package.json", "../../@uppy/xhr-upload/lib/locale.js", "../../@uppy/xhr-upload/lib/index.js"],
  "sourcesContent": ["{\n  \"name\": \"@uppy/xhr-upload\",\n  \"description\": \"Plain and simple classic HTML multipart form uploads with Uppy, as well as uploads using the HTTP PUT method.\",\n  \"version\": \"5.0.2\",\n  \"license\": \"MIT\",\n  \"type\": \"module\",\n  \"sideEffects\": false,\n  \"scripts\": {\n    \"build\": \"tsc --build tsconfig.build.json\",\n    \"typecheck\": \"tsc --build\",\n    \"test\": \"vitest run --environment=jsdom --silent='passed-only'\"\n  },\n  \"keywords\": [\n    \"file uploader\",\n    \"xhr\",\n    \"xhr upload\",\n    \"XMLHttpRequest\",\n    \"ajax\",\n    \"fetch\",\n    \"uppy\",\n    \"uppy-plugin\"\n  ],\n  \"homepage\": \"https://uppy.io\",\n  \"bugs\": {\n    \"url\": \"https://github.com/transloadit/uppy/issues\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/transloadit/uppy.git\"\n  },\n  \"files\": [\n    \"src\",\n    \"lib\",\n    \"dist\",\n    \"CHANGELOG.md\"\n  ],\n  \"exports\": {\n    \".\": \"./lib/index.js\",\n    \"./package.json\": \"./package.json\"\n  },\n  \"dependencies\": {\n    \"@uppy/companion-client\": \"^5.1.1\",\n    \"@uppy/utils\": \"^7.1.1\"\n  },\n  \"devDependencies\": {\n    \"@uppy/core\": \"^5.1.1\",\n    \"jsdom\": \"^26.1.0\",\n    \"nock\": \"^13.1.0\",\n    \"typescript\": \"^5.8.3\",\n    \"vitest\": \"^3.2.4\"\n  },\n  \"peerDependencies\": {\n    \"@uppy/core\": \"^5.1.1\"\n  }\n}", "export default {\n    strings: {\n        // Shown in the Informer if an upload is being canceled because it stalled for too long.\n        uploadStalled: 'Upload has not made any progress for %{seconds} seconds. You may want to retry it.',\n    },\n};\n", "import { BasePlugin, EventManager } from '@uppy/core';\nimport { fetcher, filterFilesToEmitUploadStarted, filterNonFailedFiles, getAllowedMetaFields, internalRateLimitedQueue, isNetworkError, NetworkError, RateLimitedQueue, } from '@uppy/utils';\nimport packageJson from '../package.json' with { type: 'json' };\nimport locale from './locale.js';\nfunction buildResponseError(xhr, err) {\n    let error = err;\n    // No error message\n    if (!error)\n        error = new Error('Upload error');\n    // Got an error message string\n    if (typeof error === 'string')\n        error = new Error(error);\n    // Got something else\n    if (!(error instanceof Error)) {\n        error = Object.assign(new Error('Upload error'), { data: error });\n    }\n    if (isNetworkError(xhr)) {\n        error = new NetworkError(error, xhr);\n        return error;\n    }\n    // @ts-expect-error request can only be set on NetworkError\n    // but we use NetworkError to distinguish between errors.\n    error.request = xhr;\n    return error;\n}\n/**\n * Set `data.type` in the blob to `file.meta.type`,\n * because we might have detected a more accurate file type in Uppy\n * https://stackoverflow.com/a/50875615\n */\nfunction setTypeInBlob(file) {\n    const dataWithUpdatedType = file.data.slice(0, file.data.size, file.meta.type);\n    return dataWithUpdatedType;\n}\nconst defaultOptions = {\n    formData: true,\n    fieldName: 'file',\n    method: 'post',\n    allowedMetaFields: true,\n    bundle: false,\n    headers: {},\n    timeout: 30 * 1000,\n    limit: 5,\n    withCredentials: false,\n    responseType: '',\n};\nexport default class XHRUpload extends BasePlugin {\n    static VERSION = packageJson.version;\n    #getFetcher;\n    requests;\n    uploaderEvents;\n    constructor(uppy, opts) {\n        super(uppy, {\n            ...defaultOptions,\n            fieldName: opts.bundle ? 'files[]' : 'file',\n            ...opts,\n        });\n        this.type = 'uploader';\n        this.id = this.opts.id || 'XHRUpload';\n        this.defaultLocale = locale;\n        this.i18nInit();\n        // Simultaneous upload limiting is shared across all uploads with this plugin.\n        if (internalRateLimitedQueue in this.opts) {\n            // @ts-ignore untyped internal\n            this.requests = this.opts[internalRateLimitedQueue];\n        }\n        else {\n            this.requests = new RateLimitedQueue(this.opts.limit);\n        }\n        if (this.opts.bundle && !this.opts.formData) {\n            throw new Error('`opts.formData` must be true when `opts.bundle` is enabled.');\n        }\n        if (this.opts.bundle && typeof this.opts.headers === 'function') {\n            throw new Error('`opts.headers` can not be a function when the `bundle: true` option is set.');\n        }\n        if (opts?.allowedMetaFields === undefined && 'metaFields' in this.opts) {\n            throw new Error('The `metaFields` option has been renamed to `allowedMetaFields`.');\n        }\n        this.uploaderEvents = Object.create(null);\n        /**\n         * xhr-upload wrapper for `fetcher` to handle user options\n         * `validateStatus`, `getResponseError`, `getResponseData`\n         * and to emit `upload-progress`, `upload-error`, and `upload-success` events.\n         */\n        this.#getFetcher = (files) => {\n            return async (url, options) => {\n                try {\n                    const res = await fetcher(url, {\n                        ...options,\n                        onBeforeRequest: (xhr, retryCount) => this.opts.onBeforeRequest?.(xhr, retryCount, files),\n                        shouldRetry: this.opts.shouldRetry,\n                        onAfterResponse: this.opts.onAfterResponse,\n                        onTimeout: (timeout) => {\n                            const seconds = Math.ceil(timeout / 1000);\n                            const error = new Error(this.i18n('uploadStalled', { seconds }));\n                            this.uppy.emit('upload-stalled', error, files);\n                        },\n                        onUploadProgress: (event) => {\n                            if (event.lengthComputable) {\n                                for (const { id } of files) {\n                                    const file = this.uppy.getFile(id);\n                                    this.uppy.emit('upload-progress', file, {\n                                        uploadStarted: file.progress.uploadStarted ?? 0,\n                                        bytesUploaded: (event.loaded / event.total) * file.size,\n                                        bytesTotal: file.size,\n                                    });\n                                }\n                            }\n                        },\n                    });\n                    let body = await this.opts.getResponseData?.(res);\n                    if (res.responseType === 'json') {\n                        body ??= res.response;\n                    }\n                    else {\n                        try {\n                            body ??= JSON.parse(res.responseText);\n                        }\n                        catch (cause) {\n                            throw new Error('@uppy/xhr-upload expects a JSON response (with a `url` property). To parse non-JSON responses, use `getResponseData` to turn your response into JSON.', { cause });\n                        }\n                    }\n                    const uploadURL = typeof body?.url === 'string' ? body.url : undefined;\n                    for (const { id } of files) {\n                        this.uppy.emit('upload-success', this.uppy.getFile(id), {\n                            status: res.status,\n                            body,\n                            uploadURL,\n                        });\n                    }\n                    return res;\n                }\n                catch (error) {\n                    if (error.name === 'AbortError') {\n                        return undefined;\n                    }\n                    const request = error.request;\n                    for (const file of files) {\n                        this.uppy.emit('upload-error', this.uppy.getFile(file.id), buildResponseError(request, error), request);\n                    }\n                    throw error;\n                }\n            };\n        };\n    }\n    getOptions(file) {\n        const overrides = this.uppy.getState().xhrUpload;\n        const { headers } = this.opts;\n        const opts = {\n            ...this.opts,\n            ...(overrides || {}),\n            ...(file.xhrUpload || {}),\n            headers: {},\n        };\n        // Support for `headers` as a function, only in the XHRUpload settings.\n        // Options set by other plugins in Uppy state or on the files themselves are still merged in afterward.\n        //\n        // ```js\n        // headers: (file) => ({ expires: file.meta.expires })\n        // ```\n        if (typeof headers === 'function') {\n            opts.headers = headers(file);\n        }\n        else {\n            Object.assign(opts.headers, this.opts.headers);\n        }\n        if (overrides) {\n            Object.assign(opts.headers, overrides.headers);\n        }\n        if (file.xhrUpload) {\n            Object.assign(opts.headers, file.xhrUpload.headers);\n        }\n        return opts;\n    }\n    addMetadata(formData, meta, opts) {\n        const allowedMetaFields = getAllowedMetaFields(opts.allowedMetaFields, meta);\n        allowedMetaFields.forEach((item) => {\n            const value = meta[item];\n            if (Array.isArray(value)) {\n                // In this case we don't transform `item` to add brackets, it's up to\n                // the user to add the brackets so it won't be overridden.\n                value.forEach((subItem) => formData.append(item, subItem));\n            }\n            else {\n                formData.append(item, value);\n            }\n        });\n    }\n    createFormDataUpload(file, opts) {\n        const formPost = new FormData();\n        this.addMetadata(formPost, file.meta, opts);\n        const dataWithUpdatedType = setTypeInBlob(file);\n        if (file.name) {\n            formPost.append(opts.fieldName, dataWithUpdatedType, file.meta.name);\n        }\n        else {\n            formPost.append(opts.fieldName, dataWithUpdatedType);\n        }\n        return formPost;\n    }\n    createBundledUpload(files, opts) {\n        const formPost = new FormData();\n        const { meta } = this.uppy.getState();\n        this.addMetadata(formPost, meta, opts);\n        files.forEach((file) => {\n            const options = this.getOptions(file);\n            const dataWithUpdatedType = setTypeInBlob(file);\n            if (file.name) {\n                formPost.append(options.fieldName, dataWithUpdatedType, file.name);\n            }\n            else {\n                formPost.append(options.fieldName, dataWithUpdatedType);\n            }\n        });\n        return formPost;\n    }\n    async #uploadLocalFile(file) {\n        const events = new EventManager(this.uppy);\n        const controller = new AbortController();\n        const uppyFetch = this.requests.wrapPromiseFunction(async () => {\n            const opts = this.getOptions(file);\n            const fetch = this.#getFetcher([file]);\n            const body = opts.formData\n                ? this.createFormDataUpload(file, opts)\n                : file.data;\n            const endpoint = typeof opts.endpoint === 'string'\n                ? opts.endpoint\n                : await opts.endpoint(file);\n            return fetch(endpoint, {\n                ...opts,\n                body,\n                signal: controller.signal,\n            });\n        });\n        events.onFileRemove(file.id, () => controller.abort());\n        events.onCancelAll(file.id, () => {\n            controller.abort();\n        });\n        try {\n            await uppyFetch().abortOn(controller.signal);\n        }\n        catch (error) {\n            // TODO: create formal error with name 'AbortError' (this comes from RateLimitedQueue)\n            if (error.message !== 'Cancelled') {\n                throw error;\n            }\n        }\n        finally {\n            events.remove();\n        }\n    }\n    async #uploadBundle(files) {\n        const controller = new AbortController();\n        const uppyFetch = this.requests.wrapPromiseFunction(async () => {\n            const optsFromState = this.uppy.getState().xhrUpload ?? {};\n            const fetch = this.#getFetcher(files);\n            const body = this.createBundledUpload(files, {\n                ...this.opts,\n                ...optsFromState,\n            });\n            const endpoint = typeof this.opts.endpoint === 'string'\n                ? this.opts.endpoint\n                : await this.opts.endpoint(files);\n            return fetch(endpoint, {\n                // headers can't be a function with bundle: true\n                ...this.opts,\n                body,\n                signal: controller.signal,\n            });\n        });\n        function abort() {\n            controller.abort();\n        }\n        // We only need to abort on cancel all because\n        // individual cancellations are not possible with bundle: true\n        this.uppy.once('cancel-all', abort);\n        try {\n            await uppyFetch().abortOn(controller.signal);\n        }\n        catch (error) {\n            // TODO: create formal error with name 'AbortError' (this comes from RateLimitedQueue)\n            if (error.message !== 'Cancelled') {\n                throw error;\n            }\n        }\n        finally {\n            this.uppy.off('cancel-all', abort);\n        }\n    }\n    #getCompanionClientArgs(file) {\n        const opts = this.getOptions(file);\n        const allowedMetaFields = getAllowedMetaFields(opts.allowedMetaFields, file.meta);\n        return {\n            ...file.remote?.body,\n            protocol: 'multipart',\n            endpoint: opts.endpoint,\n            size: file.data.size,\n            fieldname: opts.fieldName,\n            metadata: Object.fromEntries(allowedMetaFields.map((name) => [name, file.meta[name]])),\n            httpMethod: opts.method,\n            useFormData: opts.formData,\n            headers: opts.headers,\n        };\n    }\n    async #uploadFiles(files) {\n        await Promise.allSettled(files.map((file) => {\n            if (file.isRemote) {\n                const getQueue = () => this.requests;\n                const controller = new AbortController();\n                const removedHandler = (removedFile) => {\n                    if (removedFile.id === file.id)\n                        controller.abort();\n                };\n                this.uppy.on('file-removed', removedHandler);\n                const uploadPromise = this.uppy\n                    .getRequestClientForFile(file)\n                    .uploadRemoteFile(file, this.#getCompanionClientArgs(file), {\n                    signal: controller.signal,\n                    getQueue,\n                });\n                this.requests.wrapSyncFunction(() => {\n                    this.uppy.off('file-removed', removedHandler);\n                }, { priority: -1 })();\n                return uploadPromise;\n            }\n            return this.#uploadLocalFile(file);\n        }));\n    }\n    #handleUpload = async (fileIDs) => {\n        if (fileIDs.length === 0) {\n            this.uppy.log('[XHRUpload] No files to upload!');\n            return;\n        }\n        // No limit configured by the user, and no RateLimitedQueue passed in by a \"parent\" plugin\n        // (basically just AwsS3) using the internal symbol\n        // @ts-ignore untyped internal\n        if (this.opts.limit === 0 && !this.opts[internalRateLimitedQueue]) {\n            this.uppy.log('[XHRUpload] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/xhr-upload/#limit-0', 'warning');\n        }\n        this.uppy.log('[XHRUpload] Uploading...');\n        const files = this.uppy.getFilesByIds(fileIDs);\n        const filesFiltered = filterNonFailedFiles(files);\n        const filesToEmit = filterFilesToEmitUploadStarted(filesFiltered);\n        this.uppy.emit('upload-start', filesToEmit);\n        if (this.opts.bundle) {\n            // if bundle: true, we don’t support remote uploads\n            const isSomeFileRemote = filesFiltered.some((file) => file.isRemote);\n            if (isSomeFileRemote) {\n                throw new Error('Can’t upload remote files when the `bundle: true` option is set');\n            }\n            if (typeof this.opts.headers === 'function') {\n                throw new TypeError('`headers` may not be a function when the `bundle: true` option is set');\n            }\n            await this.#uploadBundle(filesFiltered);\n        }\n        else {\n            await this.#uploadFiles(filesFiltered);\n        }\n    };\n    install() {\n        if (this.opts.bundle) {\n            const { capabilities } = this.uppy.getState();\n            this.uppy.setState({\n                capabilities: {\n                    ...capabilities,\n                    individualCancellation: false,\n                },\n            });\n        }\n        this.uppy.addUploader(this.#handleUpload);\n    }\n    uninstall() {\n        if (this.opts.bundle) {\n            const { capabilities } = this.uppy.getState();\n            this.uppy.setState({\n                capabilities: {\n                    ...capabilities,\n                    individualCancellation: true,\n                },\n            });\n        }\n        this.uppy.removeUploader(this.#handleUpload);\n    }\n}\n"],
  "mappings": "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",
  "names": ["_a", "_b"]
}
